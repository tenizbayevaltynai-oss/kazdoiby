<!DOCTYPE html>
<html lang="kk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ –ê–¥–∏—è “ö–∞–∑–¥–æ–π–±—ã - “ö–∞–∑–∞“õ –®–∞—à–∫–∞—Å—ã</title>
    <style>
        /* CSS –∫–µ–π—ñ–Ω—ñ—Ä–µ–∫ “õ–æ—Å–∞–º—ã–∑ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        /* –û—Ä–Ω–∞—Ç—É —ç–∫—Ä–∞–Ω—ã */
        .setup {
            max-width: 800px;
            margin: 0 auto;
        }
        .setup.hidden {
            display: none;
        }
        .setup h2 {
            color: #667eea;
            margin-bottom: 25px;
            text-align: center;
            font-size: 1.8em;
        }
        .player-config {
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            border: 3px solid #ddd;
        }
        .player-config label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .player-config select {
            width: 100%;
            padding: 12px;
            border: 3px solid #667eea;
            border-radius: 10px;
            font-size: 1.1em;
            background: white;
            cursor: pointer;
        }
        .btn-start {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.5em;
            cursor: pointer;
            margin-top: 30px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn-start:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }
        /* –û–π—ã–Ω —ç–∫—Ä–∞–Ω—ã */
        .game {
            display: none;
        }
        .game.active {
            display: block;
        }
        /* –û–π—ã–Ω—à—ã–ª–∞—Ä –∞“õ–ø–∞—Ä–∞—Ç—ã */
        .players-info {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .player-box {
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            transition: all 0.3s;
            border: 4px solid transparent;
        }
        .player-box.blue {
            background: linear-gradient(135deg, #667eea 0%, #4c63d2 100%);
        }
        .player-box.black {
            background: linear-gradient(135deg, #434343 0%, #000000 100%);
        }
        .player-box.red {
            background: linear-gradient(135deg, #f5576c 0%, #d63447 100%);
        }
        .player-box.white {
            background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%);
            color: #333;
        }
        .player-box.active {
            border: 4px solid gold;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            transform: scale(1.05);
        }
        .player-box div {
            margin: 8px 0;
            font-size: 1.1em;
        }
        /* –¢–∞“õ—Ç–∞ */
        .board-wrapper {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            overflow-x: auto;
        }
        .board-container {
            display: inline-block;
        }
        .board-labels-top, .board-labels-bottom {
            display: flex;
            margin-bottom: 5px;
            padding-left: 40px;
        }
        .board-labels-top span, .board-labels-bottom span {
            width: 40px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        .board-with-left-labels {
            display: flex;
        }
        .board-labels-left, .board-labels-right {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            margin-right: 5px;
        }
        .board-labels-right {
            margin-left: 5px;
            margin-right: 0;
        }
        .board-labels-left span, .board-labels-right span {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
            width: 35px;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            grid-template-rows: repeat(12, 40px);
            gap: 0;
            border: 5px solid #333;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .cell.light {
            background: rgb(255, 255, 0);
        }
        .cell.dark {
            background: rgb(255, 165, 0);
        }
        .cell.oob {
            background: rgb(255, 255, 255);
        }
        .cell.selected {
            background-color: rgba(255, 255, 0, 0.4) !important;
            box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.9);
        }
        .cell.possible {
            background-color: rgba(173, 216, 230, 0.6) !important;
            box-shadow: inset 0 0 12px rgba(50, 205, 50, 0.7);
        }
        .cell.capture {
            background-color: rgba(255, 100, 100, 0.6) !important;
            box-shadow: inset 0 0 12px rgba(255, 105, 180, 0.7);
        }
        .cell:hover {
            opacity: 0.85;
        }
        /* –¢–∞—Å—Ç–∞—Ä */
        .piece {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: transform 0.2s;
            font-size: 1em;
        }
        .piece:hover {
            transform: scale(1.15);
        }
        .piece.blue {
            background: rgb(0, 0, 255);
            color: white;
        }
        .piece.black {
            background: rgb(10, 10, 10);
            color: white;
            border: 3px solid rgb(100, 100, 100);
        }
        .piece.red {
            background: rgb(255, 0, 0);
            color: white;
        }
        .piece.white {
            background: rgb(255, 255, 255);
            color: #333;
            border: 3px solid rgb(150, 150, 150);
        }
        .piece.sultan {
            font-size: 1.3em;
            border: 3px solid rgb(255, 215, 0);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.9);
            animation: glow 1.5s infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 15px rgba(255, 215, 0, 0.9); }
            to { box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }
        /* –ë–∞—Å“õ–∞—Ä—É */
        .controls {
            text-align: center;
            margin-top: 30px;
        }
        .status {
            font-size: 1.4em;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            border: 3px solid #667eea;
        }
        .btn {
            padding: 15px 30px;
            margin: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.5);
        }
        /* –•–∞–±–∞—Ä–ª–∞–º–∞–ª–∞—Ä */
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 20px 30px;
            background: #4caf50;
            color: white;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            z-index: 1000;
            animation: slideIn 0.3s;
            font-weight: bold;
            font-size: 1.1em;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        /* –ê“õ–ø–∞—Ä–∞—Ç –±–ª–æ–≥—ã */
        .info-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 15px;
            margin-top: 25px;
            border-left: 5px solid #667eea;
        }
        .info-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .info-box ul {
            margin-left: 25px;
        }
        .info-box li {
            margin: 8px 0;
            font-size: 1.05em;
        }
        /* Responsive */
        @media (max-width: 1200px) {
            .board {
                grid-template-columns: repeat(12, 35px);
                grid-template-rows: repeat(12, 35px);
            }
            .cell {
                width: 35px;
                height: 35px;
            }
            .piece {
                width: 28px;
                height: 28px;
            }
        }
        @media (max-width: 900px) {
            .board {
                grid-template-columns: repeat(12, 30px);
                grid-template-rows: repeat(12, 30px);
            }
            .cell {
                width: 30px;
                height: 30px;
            }
            .piece {
                width: 24px;
                height: 24px;
            }
            .players-info {
                grid-template-columns: 1fr 1fr;
            }
        }
        @media (max-width: 768px) {
            .board {
                grid-template-columns: repeat(12, 25px);
                grid-template-rows: repeat(12, 25px);
            }
            .cell {
                width: 25px;
                height: 25px;
            }
            .piece {
                width: 20px;
                height: 20px;
                font-size: 0.8em;
            }
            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ –ê–¥–∏—è “ö–∞–∑–¥–æ–π–±—ã</h1>
        <p class="subtitle">4 –æ–π—ã–Ω—à—ã–ª—ã “õ–∞–∑–∞“õ —à–∞—à–∫–∞—Å—ã ‚Ä¢ 12x12 —Ç–∞“õ—Ç–∞ (A B C D E F G H N P S T, 1-12) ‚Ä¢ 32 —Ç–∞—Å</p>
        <!-- –û—Ä–Ω–∞—Ç—É —ç–∫—Ä–∞–Ω—ã -->
        <div class="setup" id="setup">
            <h2>‚öôÔ∏è –û–π—ã–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ</h2>
           
            <div class="player-config">
                <label>üîµ –ö”©–∫ –æ–π—ã–Ω—à—ã (—Ç”©–º–µ–Ω–¥–µ: C1, E1, G1, N1, D2, F2, H2, P2):</label>
                <select id="blueType">
                    <option value="human">üë§ –ê–¥–∞–º</option>
                    <option value="ai-easy">ü§ñ AI (–ñ–µ“£—ñ–ª)</option>
                    <option value="ai-medium">ü§ñ AI (–û—Ä—Ç–∞)</option>
                    <option value="ai-hard">ü§ñ AI (“ö–∏—ã–Ω)</option>
                </select>
            </div>
            <div class="player-config">
                <label>‚ö´ “ö–∞—Ä–∞ –æ–π—ã–Ω—à—ã (–æ“£ –∂–∞“õ—Ç–∞: S3, S5, S7, S9, T4, T6, T8, T10):</label>
                <select id="blackType">
                    <option value="human">üë§ –ê–¥–∞–º</option>
                    <option value="ai-easy">ü§ñ AI (–ñ–µ“£—ñ–ª)</option>
                    <option value="ai-medium" selected>ü§ñ AI (–û—Ä—Ç–∞)</option>
                    <option value="ai-hard">ü§ñ AI (“ö–∏—ã–Ω)</option>
                </select>
            </div>
            <div class="player-config">
                <label>üî¥ “ö—ã–∑—ã–ª –æ–π—ã–Ω—à—ã (–∂–æ“ì–∞—Ä—ã–¥–∞: C11, E11, G11, N11, D12, F12, H12, P12):</label>
                <select id="redType">
                    <option value="human">üë§ –ê–¥–∞–º</option>
                    <option value="ai-easy">ü§ñ AI (–ñ–µ“£—ñ–ª)</option>
                    <option value="ai-medium" selected>ü§ñ AI (–û—Ä—Ç–∞)</option>
                    <option value="ai-hard">ü§ñ AI (“ö–∏—ã–Ω)</option>
                </select>
            </div>
            <div class="player-config">
                <label>‚ö™ –ê“õ –æ–π—ã–Ω—à—ã (—Å–æ–ª –∂–∞“õ—Ç–∞: A3, A5, A7, A9, B4, B6, B8, B10):</label>
                <select id="whiteType">
                    <option value="human">üë§ –ê–¥–∞–º</option>
                    <option value="ai-easy" selected>ü§ñ AI (–ñ–µ“£—ñ–ª)</option>
                    <option value="ai-medium">ü§ñ AI (–û—Ä—Ç–∞)</option>
                    <option value="ai-hard">ü§ñ AI (“ö–∏—ã–Ω)</option>
                </select>
            </div>
            <button class="btn-start" onclick="startGame()">üéÆ –û–π—ã–Ω–¥—ã –±–∞—Å—Ç–∞—É</button>
            <div class="info-box">
                <h3>üìã –û–π—ã–Ω –µ—Ä–µ–∂–µ–ª–µ—Ä—ñ:</h3>
                <ul>
                    <li>‚úÖ –¢–∞“õ—Ç–∞: 12x12 (A B C D E F G H N P S T, 1-12) = 144 —Ç–æ—Ä</li>
                    <li>‚úÖ –ö–µ–∑–µ–∫: –ö”©–∫ ‚Üí “ö–∞—Ä–∞ ‚Üí “ö—ã–∑—ã–ª ‚Üí –ê“õ (—Å–∞“ì–∞—Ç —Ç—ñ–ª—ñ–Ω–µ “õ–∞—Ä—Å—ã)</li>
                    <li>‚úÖ –°–∞—Ä–±–∞–∑: –∞–ª“ì–∞ –¥–∏–∞–≥–æ–Ω–∞–ª—å (–æ“£/—Å–æ–ª) 1 —Ç–æ—Ä</li>
                    <li>‚úÖ –ñ–æ—é –º—ñ–Ω–¥–µ—Ç—Ç—ñ! 4 –¥–∏–∞–≥–æ–Ω–∞–ª—å –±–∞“ì—ã—Ç—Ç–∞ –∂–æ—é</li>
                    <li>‚úÖ –®–µ—Ç–∫–µ –∂–µ—Ç—Å–µ ‚Üí –°“±–ª—Ç–∞–Ω üëë (4 –±–∞“ì—ã—Ç—Ç–∞ –∂“Ø—Ä–µ–¥—ñ)</li>
                    <li>‚úÖ –ñ–µ“£—ñ—Å: “õ–∞—Ä—Å—ã–ª–∞—Å—Ç–∞—Ä–¥—ã –∂–æ—é –Ω–µ–º–µ—Å–µ –µ“£ –∫”©–ø “±–ø–∞–π</li>
                    <li>‚úÖ “∞–ø–∞–π: –°–∞—Ä–±–∞–∑ = 1, –°“±–ª—Ç–∞–Ω = 3</li>
                </ul>
            </div>
        </div>
        <!-- –û–π—ã–Ω —ç–∫—Ä–∞–Ω—ã -->
        <div class="game" id="game">
            <div class="players-info" id="playersInfo"></div>
           
            <div class="board-wrapper">
                <div class="board-container">
                    <div class="board-labels-top" id="topLabels"></div>
                    <div class="board-with-left-labels">
                        <div class="board-labels-left" id="leftLabels"></div>
                        <div class="board" id="board"></div>
                        <div class="board-labels-right" id="rightLabels"></div>
                    </div>
                    <div class="board-labels-bottom" id="bottomLabels"></div>
                </div>
            </div>
           
            <div class="controls">
                <div class="status" id="status">–ö–µ–∑–µ–∫: –ö”©–∫ üîµ</div>
                <button class="btn" onclick="restartGame()">üîÑ “ö–∞–π—Ç–∞ –±–∞—Å—Ç–∞—É</button>
                <button class="btn" onclick="showHint()">üí° –ö–µ“£–µ—Å</button>
                <button class="btn" onclick="showRules()">üìñ –ï—Ä–µ–∂–µ–ª–µ—Ä</button>
            </div>
        </div>
    </div>
    <script>
        // --- –û–π—ã–Ω–Ω—ã“£ –Ω–µ–≥—ñ–∑–≥—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ ---
        const BOARD_ROWS = 12;
        const BOARD_COLS = 12;
        const SQUARE_SIZE = 40;

        // –¢“Ø—Å—Ç–µ—Ä (RGB)
        const COLOR_LIGHT_SQUARE = 'rgb(255, 255, 0)'; // –ê—à—ã“õ —Ç–æ—Ä
        const COLOR_DARK_SQUARE = 'rgb(255, 165, 0)'; // “ö–æ—é —Ç–æ—Ä (–∂“Ø—Ä—ñ—Å —Ç–æ—Ä—ã)
        const COLOR_OOB = 'rgb(255, 255, 255)'; // –û–π—ã–Ω–Ω–∞–Ω —Ç—ã—Å —Ç–æ—Ä

        // –û–π—ã–Ω—à—ã–ª–∞—Ä–¥—ã“£ —Ç“Ø—Å—Ç–µ—Ä—ñ
        const PLAYER_COLORS = {
            'blue': 'rgb(0, 0, 255)',
            'black': 'rgb(10, 10, 10)',
            'red': 'rgb(255, 0, 0)',
            'white': 'rgb(255, 255, 255)'
        };

        // Pygame –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—Ç–∞—Ä—ã–Ω–∞ (row, col) –∞—É–¥–∞—Ä—É “Ø—à—ñ–Ω
        // 1-—à—ñ “õ–∞—Ç–∞—Ä = –∏–Ω–¥–µ–∫—Å 11, 12-—à—ñ “õ–∞—Ç–∞—Ä = –∏–Ω–¥–µ–∫—Å 0
        const ROW_MAP = {};
        for (let i = 1; i <= BOARD_ROWS; i++) {
            ROW_MAP[i] = BOARD_ROWS - i;
        }

        // A-T ”ô—Ä—ñ–ø—Ç–µ—Ä—ñ 0-11 –∏–Ω–¥–µ–∫—Å—Ç–µ—Ä—ñ–Ω–µ
        const COL_MAP = {
            'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5,
            'G': 6, 'H': 7, 'N': 8, 'P': 9, 'S': 10, 'T': 11
        };

        const colLabels = Object.keys(COL_MAP);
        const rowLabels = Array.from({length: BOARD_ROWS}, (_, i) => BOARD_ROWS - i);

        // –û–π—ã–Ω–Ω–∞–Ω —Ç—ã—Å —Ç–æ—Ä–ª–∞—Ä (Out-of-Bounds) (12 —Ç–æ—Ä)
        const OOB_SQUARES = [
            [ROW_MAP[1], COL_MAP['A']], [ROW_MAP[2], COL_MAP['A']], [ROW_MAP[1], COL_MAP['B']], // –¢”©–º–µ–Ω–≥—ñ-—Å–æ–ª
            [ROW_MAP[1], COL_MAP['S']], [ROW_MAP[1], COL_MAP['T']], [ROW_MAP[2], COL_MAP['T']], // –¢”©–º–µ–Ω–≥—ñ-–æ“£
            [ROW_MAP[12], COL_MAP['A']], [ROW_MAP[11], COL_MAP['A']], [ROW_MAP[12], COL_MAP['B']], // –ñ–æ“ì–∞—Ä“ì—ã-—Å–æ–ª
            [ROW_MAP[12], COL_MAP['S']], [ROW_MAP[11], COL_MAP['T']], [ROW_MAP[12], COL_MAP['T']] // –ñ–æ“ì–∞—Ä“ì—ã-–æ“£
        ];

        // –°–∞—Ä–±–∞–∑–¥–∞—Ä–¥—ã“£ –±–∞—Å—Ç–∞–ø“õ—ã –æ—Ä–Ω–∞–ª–∞—Å—É—ã
        const STARTING_POSITIONS = {
            'blue': [
                [ROW_MAP[1], COL_MAP['C']], [ROW_MAP[1], COL_MAP['E']], [ROW_MAP[1], COL_MAP['G']], [ROW_MAP[1], COL_MAP['N']],
                [ROW_MAP[2], COL_MAP['D']], [ROW_MAP[2], COL_MAP['F']], [ROW_MAP[2], COL_MAP['H']], [ROW_MAP[2], COL_MAP['P']]
            ],
            'black': [
                [ROW_MAP[4], COL_MAP['T']], [ROW_MAP[6], COL_MAP['T']], [ROW_MAP[8], COL_MAP['T']], [ROW_MAP[10], COL_MAP['T']],
                [ROW_MAP[3], COL_MAP['S']], [ROW_MAP[5], COL_MAP['S']], [ROW_MAP[7], COL_MAP['S']], [ROW_MAP[9], COL_MAP['S']]
            ],
            'red': [
                [ROW_MAP[12], COL_MAP['P']], [ROW_MAP[12], COL_MAP['H']], [ROW_MAP[12], COL_MAP['F']], [ROW_MAP[12], COL_MAP['D']],
                [ROW_MAP[11], COL_MAP['N']], [ROW_MAP[11], COL_MAP['G']], [ROW_MAP[11], COL_MAP['E']], [ROW_MAP[11], COL_MAP['C']]
            ],
            'white': [
                [ROW_MAP[3], COL_MAP['A']], [ROW_MAP[5], COL_MAP['A']], [ROW_MAP[7], COL_MAP['A']], [ROW_MAP[9], COL_MAP['A']],
                [ROW_MAP[4], COL_MAP['B']], [ROW_MAP[6], COL_MAP['B']], [ROW_MAP[8], COL_MAP['B']], [ROW_MAP[10], COL_MAP['B']]
            ]
        };

        // –°–∞—Ä–±–∞–∑–¥—ã“£ "–∞–ª“ì–∞" –∂“Ø—Ä—É –±–∞“ì—ã—Ç—Ç–∞—Ä—ã
        const PAWN_FORWARD_MOVES = {
            'blue': [[-1, -1], [-1, 1]], // –ñ–æ“ì–∞—Ä—ã (row -)
            'black': [[-1, -1], [1, -1]], // –°–æ–ª“ì–∞ (col -)
            'red': [[1, -1], [1, 1]], // –¢”©–º–µ–Ω (row +)
            'white': [[-1, 1], [1, 1]] // –û“£“ì–∞ (col +)
        };

        // –ñ–æ—é “Ø—à—ñ–Ω –±–∞—Ä–ª—ã“õ 4 –±–∞“ì—ã—Ç
        const ALL_DIRECTIONS = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

        // –°“±–ª—Ç–∞–Ω –∞—Ç–∞–Ω—É —Å—ã–∑—ã“õ—Ç–∞—Ä—ã
        const PROMOTION_LINES = {
            'blue': 0, // 12-—à—ñ “õ–∞—Ç–∞—Ä (—ñ–Ω–¥–µ–∫—Å 0)
            'black': 0, // A –±–∞“ì–∞–Ω—ã (—ñ–Ω–¥–µ–∫—Å 0)
            'red': 11, // 1-—à—ñ “õ–∞—Ç–∞—Ä (—ñ–Ω–¥–µ–∫—Å 11)
            'white': 11 // T –±–∞“ì–∞–Ω—ã (—ñ–Ω–¥–µ–∫—Å 11)
        };

        // –û–π—ã–Ω—à—ã –∫–µ–∑–µ–≥—ñ
        const TURN_ORDER = ['blue', 'black', 'red', 'white'];

        class Piece {
            constructor(row, col, player) {
                this.row = row;
                this.col = col;
                this.player = player;
                this.isSultan = false;
            }
            promote() {
                this.isSultan = true;
            }
        }

        class KazdoibaGame {
            constructor() {
                this.board = this._setupBoard();
                this.turnIndex = 0;
                this.currentPlayer = TURN_ORDER[this.turnIndex];
                this.selectedPiece = null;
                this.validMoves = {};
                this.mandatoryCaptures = {};
                this.inMultiJump = false;
                this.capturedInTurn = new Set();
                this.activePlayers = [...TURN_ORDER];
                this.playerPiecesCount = TURN_ORDER.reduce((acc, p) => { acc[p] = STARTING_POSITIONS[p].length; return acc; }, {});
                this.winner = null;
                this.playerTypes = {
                    'blue': document.getElementById('blueType').value,
                    'black': document.getElementById('blackType').value,
                    'red': document.getElementById('redType').value,
                    'white': document.getElementById('whiteType').value
                };
                this._findAllMandatoryCaptures();
                this.updateBoard();
                this.updateHud();
                if (this.playerTypes[this.currentPlayer] !== 'human') {
                    setTimeout(() => this.makeAiMove(), 500);
                }
            }
            _setupBoard() {
                const board = Array.from({ length: BOARD_ROWS }, () => Array(BOARD_COLS).fill(null));
                for (let player in STARTING_POSITIONS) {
                    for (let [r, c] of STARTING_POSITIONS[player]) {
                        board[r][c] = new Piece(r, c, player);
                    }
                }
                return board;
            }
            _is_valid_pos(r, c) {
                return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS && !OOB_SQUARES.some(([rr, cc]) => rr === r && cc === c);
            }
            getPiece(r, c) {
                if (this._is_valid_pos(r, c)) {
                    return this.board[r][c];
                }
                return null;
            }
            updateBoard() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    cell.innerHTML = '';
                    cell.classList.remove('selected', 'possible', 'capture');
                    const piece = this.getPiece(r, c);
                    if (piece) {
                        const pieceDiv = document.createElement('div');
                        pieceDiv.classList.add('piece', piece.player);
                        if (piece.isSultan) {
                            pieceDiv.classList.add('sultan');
                            pieceDiv.innerText = 'üëë';
                        }
                        cell.appendChild(pieceDiv);
                    }
                });
                if (this.selectedPiece) {
                    const cell = document.querySelector(`[data-row="${this.selectedPiece.row}"][data-col="${this.selectedPiece.col}"]`);
                    if (cell) cell.classList.add('selected');
                }
                for (let key in this.validMoves) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (this.validMoves[key].length > 0) {
                            cell.classList.add('capture');
                        } else {
                            cell.classList.add('possible');
                        }
                    }
                }
            }
            updateHud() {
                const status = document.getElementById('status');
                if (this.winner) {
                    status.textContent = `–ñ–ï“¢–Ü–ú–ü–ê–ó: ${this.winner.toUpperCase()}`;
                } else {
                    status.textContent = `–ö–µ–∑–µ–∫: ${this.currentPlayer.toUpperCase()}`;
                    if (Object.keys(this.mandatoryCaptures).length > 0 && !this.inMultiJump) {
                        status.textContent += ' | –ú–Ü–ù–î–ï–¢–¢–Ü –ñ–û–Æ –ë–ê–†!';
                    }
                }
                const playerBoxes = document.querySelectorAll('.player-box');
                playerBoxes.forEach(box => {
                    box.classList.remove('active');
                    if (box.dataset.player === this.currentPlayer) {
                        box.classList.add('active');
                    }
                    const countDiv = box.querySelector('.count');
                    if (countDiv) countDiv.textContent = `–¢–∞—Å—Ç–∞—Ä: ${this.playerPiecesCount[box.dataset.player]}`;
                });
            }
            handleClick(r, c) {
                if (this.winner) return;
                if (this.playerTypes[this.currentPlayer] !== 'human') return;
                if (!this._is_valid_pos(r, c)) return;
                const moveKey = `${r},${c}`;
                if (moveKey in this.validMoves) {
                    const jumpedPositions = this.validMoves[moveKey];
                    this._movePiece(this.selectedPiece, r, c, jumpedPositions);
                    this.updateBoard();
                    this.updateHud();
                    return;
                }
                const piece = this.getPiece(r, c);
                if (piece && piece.player === this.currentPlayer) {
                    if (this.inMultiJump) return;
                    const pieceKey = `${r},${c}`;
                    if (Object.keys(this.mandatoryCaptures).length > 0 && !(pieceKey in this.mandatoryCaptures)) return;
                    this._selectPiece(piece);
                    this.updateBoard();
                    return;
                }
                if (!this.inMultiJump) {
                    this._unselectPiece();
                    this.updateBoard();
                }
            }
            _selectPiece(piece) {
                this.selectedPiece = piece;
                if (this.inMultiJump) {
                    this.validMoves = this._findCapturesForPiece(piece, this.capturedInTurn);
                } else {
                    const pieceKey = `${piece.row},${piece.col}`;
                    if (Object.keys(this.mandatoryCaptures).length > 0) {
                        this.validMoves = this.mandatoryCaptures[pieceKey] || {};
                    } else {
                        this.validMoves = this._findSimpleMovesForPiece(piece);
                    }
                }
            }
            _unselectPiece() {
                this.selectedPiece = null;
                this.validMoves = {};
            }
            _findAllMandatoryCaptures() {
                let allCaptures = {};
                let maxCapt = 0;
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        let piece = this.getPiece(r, c);
                        if (piece && piece.player === this.currentPlayer) {
                            let captures = this._findCapturesForPiece(piece, new Set());
                            if (Object.keys(captures).length > 0) {
                                let pieceMax = Math.max(...Object.values(captures).map(j => j.length));
                                maxCapt = Math.max(maxCapt, pieceMax);
                                allCaptures[`${r},${c}`] = captures;
                            }
                        }
                    }
                }
                this.mandatoryCaptures = {};
                for (let pos in allCaptures) {
                    let captures = allCaptures[pos];
                    let filtered = {};
                    for (let land in captures) {
                        if (captures[land].length === maxCapt) {
                            filtered[land] = captures[land];
                        }
                    }
                    if (Object.keys(filtered).length > 0) {
                        this.mandatoryCaptures[pos] = filtered;
                    }
                }
            }
            _findCapturesForPiece(piece, capturedInSequence) {
                const moves = {};
                const findJumps = (r, c, currentPath, capturedSet) => {
                    let foundJump = false;
                    if (piece.isSultan) {
                        for (let [dr, dc] of ALL_DIRECTIONS) {
                            let jumpedPos = null;
                            for (let i = 1; i < BOARD_ROWS; i++) {
                                let checkR = r + i * dr;
                                let checkC = c + i * dc;
                                if (!this._is_valid_pos(checkR, checkC)) break;
                                let checkPiece = this.getPiece(checkR, checkC);
                                if (checkPiece) {
                                    const checkKey = `${checkR},${checkC}`;
                                    if (capturedSet.has(checkKey)) break;
                                    if (checkPiece.player === this.currentPlayer) break;
                                    if (!jumpedPos && !capturedSet.has(checkKey)) {
                                        jumpedPos = [checkR, checkC];
                                        continue;
                                    }
                                    if (jumpedPos) break;
                                }
                                if (jumpedPos) {
                                    let landR = checkR;
                                    let landC = checkC;
                                    const landKey = `${landR},${landC}`;
                                    if (capturedSet.has(landKey)) continue;
                                    foundJump = true;
                                    let newCapturedSet = new Set(capturedSet);
                                    newCapturedSet.add(`${jumpedPos[0]},${jumpedPos[1]}`);
                                    let newPath = [...currentPath, [landR, landC]];
                                    findJumps(landR, landC, newPath, newCapturedSet);
                                    break; // Since long range, stop after landing
                                }
                            }
                        }
                    } else {
                        for (let [dr, dc] of ALL_DIRECTIONS) {
                            let jumpedR = r + dr;
                            let jumpedC = c + dc;
                            let landR = r + 2 * dr;
                            let landC = c + 2 * dc;
                            const landKey = `${landR},${landC}`;
                            if (!this._is_valid_pos(landR, landC) || capturedSet.has(landKey)) continue;
                            let jumpedPiece = this.getPiece(jumpedR, jumpedC);
                            let landPiece = this.getPiece(landR, landC);
                            const jumpedKey = `${jumpedR},${jumpedC}`;
                            if (jumpedPiece && jumpedPiece.player !== this.currentPlayer && !capturedSet.has(jumpedKey) && !landPiece) {
                                foundJump = true;
                                let newCapturedSet = new Set(capturedSet);
                                newCapturedSet.add(jumpedKey);
                                let newPath = [...currentPath, [landR, landC]];
                                findJumps(landR, landC, newPath, newCapturedSet);
                            }
                        }
                    }
                    if (!foundJump && currentPath.length > 1) {
                        let finalLandPos = currentPath[currentPath.length - 1];
                        let key = `${finalLandPos[0]},${finalLandPos[1]}`;
                        let allJumpedPos = Array.from(capturedSet).filter(s => !capturedInSequence.has(s)).map(s => s.split(',').map(Number));
                        if (!(key in moves) || allJumpedPos.length > moves[key].length) {
                            moves[key] = allJumpedPos;
                        }
                    }
                };
                findJumps(piece.row, piece.col, [[piece.row, piece.col]], new Set([...capturedInSequence]));
                return moves;
            }
            _findSimpleMovesForPiece(piece) {
                let moves = {};
                if (piece.isSultan) {
                    for (let [dr, dc] of ALL_DIRECTIONS) {
                        for (let i = 1; i < BOARD_ROWS; i++) {
                            let r = piece.row + i * dr;
                            let c = piece.col + i * dc;
                            if (!this._is_valid_pos(r, c)) break;
                            if (this.getPiece(r, c) === null) {
                                moves[`${r},${c}`] = [];
                            } else {
                                break;
                            }
                        }
                    }
                } else {
                    for (let [dr, dc] of PAWN_FORWARD_MOVES[piece.player]) {
                        let r = piece.row + dr;
                        let c = piece.col + dc;
                        if (this._is_valid_pos(r, c) && this.getPiece(r, c) === null) {
                            moves[`${r},${c}`] = [];
                        }
                    }
                }
                return moves;
            }
            _movePiece(piece, newRow, newCol, jumpedPositions) {
                this.board[piece.row][piece.col] = null;
                piece.row = newRow;
                piece.col = newCol;
                this.board[newRow][newCol] = piece;
                let isCaptureMove = jumpedPositions.length > 0;
                let promotedThisMove = false;
                if (isCaptureMove) {
                    jumpedPositions.forEach(([jr, jc]) => {
                        this.capturedInTurn.add(`${jr},${jc}`);
                    });
                }
                if (!piece.isSultan) {
                    let player = piece.player;
                    let promotionLine = PROMOTION_LINES[player];
                    if ((player === 'blue' || player === 'red') && piece.row === promotionLine ||
                        (player === 'black' || player === 'white') && piece.col === promotionLine) {
                        piece.promote();
                        promotedThisMove = true;
                    }
                }
                if (isCaptureMove) {
                    this._selectPiece(piece);
                    if (Object.keys(this.validMoves).length > 0) {
                        this.inMultiJump = true;
                        return;
                    }
                }
                this._endTurn();
            }
            _endTurn() {
                this.capturedInTurn.forEach(s => {
                    let [r, c] = s.split(',').map(Number);
                    let piece = this.board[r][c];
                    if (piece) {
                        this.playerPiecesCount[piece.player]--;
                    }
                    this.board[r][c] = null;
                });
                this._unselectPiece();
                this.inMultiJump = false;
                this.capturedInTurn = new Set();
                this.activePlayers = this.activePlayers.filter(p => this.playerPiecesCount[p] > 0);
                if (this.activePlayers.length <= 1) {
                    this.winner = this.activePlayers[0] || null;
                    this.updateHud();
                    return;
                }
                let nextIndex = (this.turnIndex + 1) % TURN_ORDER.length;
                while (true) {
                    this.turnIndex = nextIndex;
                    this.currentPlayer = TURN_ORDER[this.turnIndex];
                    if (!this.activePlayers.includes(this.currentPlayer)) {
                        nextIndex = (nextIndex + 1) % TURN_ORDER.length;
                        continue;
                    }
                    this._findAllMandatoryCaptures();
                    if (Object.keys(this.mandatoryCaptures).length > 0 || this._checkForAnySimpleMove()) {
                        break;
                    } else {
                        this.activePlayers = this.activePlayers.filter(p => p !== this.currentPlayer);
                        if (this.activePlayers.length <= 1) {
                            this.winner = this.activePlayers[0] || null;
                            this.updateHud();
                            break;
                        }
                    }
                    nextIndex = (nextIndex + 1) % TURN_ORDER.length;
                }
                this.updateHud();
                if (this.playerTypes[this.currentPlayer] !== 'human') {
                    setTimeout(() => this.makeAiMove(), 500);
                }
            }
            _checkForAnySimpleMove() {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        let piece = this.getPiece(r, c);
                        if (piece && piece.player === this.currentPlayer) {
                            if (Object.keys(this._findSimpleMovesForPiece(piece)).length > 0) return true;
                        }
                    }
                }
                return false;
            }
            makeAiMove() {
                if (this.winner) return;
                let level = this.playerTypes[this.currentPlayer].split('-')[1] || 'easy';
                let chooseMax = (level === 'medium' || level === 'hard');
                if (this.inMultiJump) {
                    if (Object.keys(this.validMoves).length === 0) return;
                    let moveKeys = Object.keys(this.validMoves);
                    let movePosStr;
                    if (chooseMax) {
                        let maxLen = Math.max(...Object.values(this.validMoves).map(j => j.length));
                        let candidates = moveKeys.filter(k => this.validMoves[k].length === maxLen);
                        movePosStr = candidates[Math.floor(Math.random() * candidates.length)];
                    } else {
                        movePosStr = moveKeys[Math.floor(Math.random() * moveKeys.length)];
                    }
                    let [r, c] = movePosStr.split(',').map(Number);
                    let jumped = this.validMoves[movePosStr];
                    this._movePiece(this.selectedPiece, r, c, jumped);
                    this.updateBoard();
                    this.updateHud();
                    if (this.inMultiJump) {
                        setTimeout(() => this.makeAiMove(), 500);
                    }
                    return;
                }
                let selectedPosStr;
                let movePosStr;
                let jumped = [];
                if (Object.keys(this.mandatoryCaptures).length > 0) {
                    let pieceKeys = Object.keys(this.mandatoryCaptures);
                    selectedPosStr = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
                    let piece = this.getPiece(...selectedPosStr.split(',').map(Number));
                    this._selectPiece(piece);
                    let moveKeys = Object.keys(this.validMoves);
                    if (chooseMax) {
                        let maxLen = Math.max(...Object.values(this.validMoves).map(j => j.length));
                        let candidates = moveKeys.filter(k => this.validMoves[k].length === maxLen);
                        movePosStr = candidates[Math.floor(Math.random() * candidates.length)];
                    } else {
                        movePosStr = moveKeys[Math.floor(Math.random() * moveKeys.length)];
                    }
                    jumped = this.validMoves[movePosStr];
                } else {
                    let allSimple = {};
                    for (let r = 0; r < BOARD_ROWS; r++) {
                        for (let c = 0; c < BOARD_COLS; c++) {
                            let p = this.getPiece(r, c);
                            if (p && p.player === this.currentPlayer) {
                                let moves = this._findSimpleMovesForPiece(p);
                                if (Object.keys(moves).length > 0) {
                                    allSimple[`${r},${c}`] = moves;
                                }
                            }
                        }
                    }
                    if (Object.keys(allSimple).length === 0) {
                        this._endTurn();
                        this.updateBoard();
                        this.updateHud();
                        return;
                    }
                    let pieceKeys = Object.keys(allSimple);
                    selectedPosStr = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
                    let piece = this.getPiece(...selectedPosStr.split(',').map(Number));
                    this._selectPiece(piece);
                    let moveKeys = Object.keys(this.validMoves);
                    movePosStr = moveKeys[Math.floor(Math.random() * moveKeys.length)];
                    jumped = [];
                }
                let [r, c] = movePosStr.split(',').map(Number);
                let piece = this.getPiece(...selectedPosStr.split(',').map(Number));
                this._movePiece(piece, r, c, jumped);
                this.updateBoard();
                this.updateHud();
                if (this.inMultiJump) {
                    setTimeout(() => this.makeAiMove(), 500);
                }
            }
        }

        let game;

        function startGame() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.add('active');

            // Populate labels
            const topLabels = document.getElementById('topLabels');
            const bottomLabels = document.getElementById('bottomLabels');
            const leftLabels = document.getElementById('leftLabels');
            const rightLabels = document.getElementById('rightLabels');
            colLabels.forEach(label => {
                const spanTop = document.createElement('span');
                spanTop.textContent = label;
                topLabels.appendChild(spanTop);
                const spanBottom = document.createElement('span');
                spanBottom.textContent = label;
                bottomLabels.appendChild(spanBottom);
            });
            rowLabels.forEach(label => {
                const spanLeft = document.createElement('span');
                spanLeft.textContent = label;
                leftLabels.appendChild(spanLeft);
                const spanRight = document.createElement('span');
                spanRight.textContent = label;
                rightLabels.appendChild(spanRight);
            });

            // Create board cells
            const board = document.getElementById('board');
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    const isOob = OOB_SQUARES.some(([rr, cc]) => rr === r && cc === c);
                    if (isOob) {
                        cell.classList.add('oob');
                    } else {
                        cell.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    }
                    cell.addEventListener('click', (e) => {
                        const r = parseInt(e.currentTarget.dataset.row);
                        const c = parseInt(e.currentTarget.dataset.col);
                        game.handleClick(r, c);
                    });
                    board.appendChild(cell);
                }
            }

            // Create players info
            const playersInfo = document.getElementById('playersInfo');
            TURN_ORDER.forEach(player => {
                const box = document.createElement('div');
                box.classList.add('player-box', player);
                box.dataset.player = player;
                box.innerHTML = `
                    <div>${player.toUpperCase()}</div>
                    <div class="type">${game ? game.playerTypes[player] : ''}</div>
                    <div class="count">–¢–∞—Å—Ç–∞—Ä: 8</div>
                `;
                playersInfo.appendChild(box);
            });

            // Start game
            game = new KazdoibaGame();

            // Add OOB texts (optional, adjusted for size)
            const boardRect = board.getBoundingClientRect();
            const scale = SQUARE_SIZE / 60;
            const oobTexts = [
                {text: "“ö–∞–∑–¥–æ–π–±—ã", color: 'rgb(0,0,255)', pos: {r:11, c:0}, angle: -90, shift_x: -8 * scale, shift_y: -30 * scale},
                {text: "“ö–∞–∑–¥–æ–π–±—ã", color: 'rgb(0,0,255)', pos: {r:11, c:11}, angle: 0, shift_x: -30 * scale, shift_y: 8 * scale},
                {text: "“ö–∞–∑–¥–æ–π–±—ã", color: 'rgb(0,0,255)', pos: {r:0, c:0}, angle: 180, shift_x: 30 * scale, shift_y: 0},
                {text: "“ö–∞–∑–¥–æ–π–±—ã", color: 'rgb(0,0,255)', pos: {r:0.5, c:11.5}, angle: 90, shift_x: -30 * scale, shift_y:0}
            ];
            const adiyaTexts = [
                {text: "–ê–î–ò–Ø", color: 'rgb(255,0,0)', pos: {r:10, c:1}, angle: 0, shift_x: -15 * scale, shift_y: 70 * scale},
                {text: "–ê–î–ò–Ø", color: 'rgb(255,0,0)', pos: {r:10, c:11.5}, angle: 90, shift_x: -25 * scale, shift_y: 15 * scale},
                {text: "–ê–î–ò–Ø", color: 'rgb(255,0,0)', pos: {r:0, c:-1.5}, angle: -90, shift_x: 80 * scale, shift_y: 45 * scale},
                {text: "–ê–î–ò–Ø", color: 'rgb(255,0,0)', pos: {r:0.4, c:10.2}, angle: 180, shift_x: 4 * scale, shift_y: -30 * scale}
            ];
            [...oobTexts, ...adiyaTexts].forEach(({text, color, pos, angle, shift_x, shift_y}) => {
                const div = document.createElement('div');
                div.textContent = text;
                div.style.position = 'absolute';
                div.style.color = color;
                div.style.fontSize = '24px';
                div.style.fontWeight = 'bold';
                div.style.transform = `rotate(${angle}deg)`;
                div.style.transformOrigin = 'center';
                div.style.whiteSpace = 'nowrap';
                const x = boardRect.left + pos.c * SQUARE_SIZE + SQUARE_SIZE / 2 + shift_x;
                const y = boardRect.top + pos.r * SQUARE_SIZE + SQUARE_SIZE / 2 + shift_y;
                div.style.left = `${x}px`;
                div.style.top = `${y}px`;
                document.body.appendChild(div);
            });
        }

        function restartGame() {
            location.reload();
        }

        function showHint() {
            alert('–ö–µ“£–µ—Å: –ú—ñ–Ω–¥–µ—Ç—Ç—ñ –∂–æ—é–¥—ã –æ—Ä—ã–Ω–¥–∞“£—ã–∑ –Ω–µ–º–µ—Å–µ –∞–ª“ì–∞ –∂“Ø—Ä—ñ“£—ñ–∑.');
        }

        function showRules() {
            alert('–ï—Ä–µ–∂–µ–ª–µ—Ä: –¢–∞“õ—Ç–∞ 12x12, –∂–æ—é –º—ñ–Ω–¥–µ—Ç—Ç—ñ, —Å“±–ª—Ç–∞–Ω —à–µ—Ç—Ç–µ –∞—Ç–∞–ª–∞–¥—ã.');
        }

        console.log('üéÆ –ê–¥–∏—è “ö–∞–∑–¥–æ–π–±—ã –¥–∞–π—ã–Ω–¥–∞–ª—É–¥–∞...');
        console.log('üìê –¢–∞“õ—Ç–∞: 12x12 (A B C D E F G H N P S T, 1-12)');
        console.log('üéØ 32 —Ç–∞—Å: 4 –æ–π—ã–Ω—à—ã x 8 —Ç–∞—Å');
    </script>
</body>
</html>